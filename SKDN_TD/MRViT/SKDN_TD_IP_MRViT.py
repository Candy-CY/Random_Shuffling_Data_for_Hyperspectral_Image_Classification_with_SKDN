#!/usr/bin/python3
# _*_ coding: utf-8 _*_
# Copyright (C) 2023 - 2023 Candy, Inc. All Rights Reserved 
# @Time        : 2023/10/16 16:10
# @Filename    : SKDN_TD_IP_MRViT.py
# @Author      : Candy
# @Email       : 2021010130@jxstnu.edu.cn
# @School      : Jiangxi Science and Technology Normal University
# @Reference   : https://github.com/Candy-CY/Hyperspectral-Image-Classification-Models/tree/main/MRViT
# @IDE         : PyCharm
# The core of Code are Random Shuffling Strategy and RFL, which show in readme.
import numpy as np
import scipy.io as sio
from sklearn.decomposition import PCA
from sklearn.model_selection import train_test_split
from sklearn.metrics import confusion_matrix, accuracy_score, classification_report, cohen_kappa_score
import torch
import torch.nn as nn
import torch.optim as optim
from operator import truediv
import time, os, math
import torch.utils.model_zoo as model_zoo
import torch.nn.functional as F
from einops import rearrange, repeat
import torch.nn.init as init
import random

#打乱整体数据的百分之几后送入MRVIT中训练

def loadData():
    # 读入数据
    data = sio.loadmat('/kaggle/input/hybridsn/data/Indian_pines_corrected.mat')['indian_pines_corrected']
    labels = sio.loadmat('/kaggle/input/hybridsn/data/Indian_pines_gt.mat')['indian_pines_gt']
    return data, labels


def infoChange(X, numComponents):
    X_copy = np.zeros((X.shape[0], X.shape[1], X.shape[2]))
    half = int(numComponents / 2)
    for i in range(0, half - 1):
        X_copy[:, :, i] = X[:, :, (half - i) * 2 - 1]
    for i in range(half, numComponents):
        X_copy[:, :, i] = X[:, :, (i - half) * 2]
    X = X_copy
    return X


# 对高光谱数据 X 应用 PCA 变换
def applyPCA(X, numComponents):
    newX = np.reshape(X, (-1, X.shape[2]))
    pca = PCA(n_components=numComponents, whiten=True)
    newX = pca.fit_transform(newX)
    newX = np.reshape(newX, (X.shape[0], X.shape[1], numComponents))
    newX = infoChange(newX, numComponents)
    return newX


# 对单个像素周围提取 patch 时，边缘像素就无法取了，因此，给这部分像素进行 padding 操作
def padWithZeros(X, margin=2):
    newX = np.zeros((X.shape[0] + 2 * margin, X.shape[1] + 2 * margin, X.shape[2]))
    x_offset = margin
    y_offset = margin
    newX[x_offset:X.shape[0] + x_offset, y_offset:X.shape[1] + y_offset, :] = X
    return newX


# 在每个像素周围提取 patch ，然后创建成符合 keras 处理的格式
def createImageCubes(X, y, windowSize=5, removeZeroLabels=True):
    # 给 X 做 padding
    margin = int((windowSize - 1) / 2)
    zeroPaddedX = padWithZeros(X, margin=margin)
    # split patches
    patchesData = np.zeros((X.shape[0] * X.shape[1], windowSize, windowSize, X.shape[2]))
    patchesLabels = np.zeros((X.shape[0] * X.shape[1]))
    patchIndex = 0
    for r in range(margin, zeroPaddedX.shape[0] - margin):
        for c in range(margin, zeroPaddedX.shape[1] - margin):
            patch = zeroPaddedX[r - margin:r + margin + 1, c - margin:c + margin + 1]
            patchesData[patchIndex, :, :, :] = patch
            patchesLabels[patchIndex] = y[r - margin, c - margin]
            patchIndex = patchIndex + 1
    if removeZeroLabels:
        patchesData = patchesData[patchesLabels > 0, :, :, :]
        patchesLabels = patchesLabels[patchesLabels > 0]
        patchesLabels -= 1
    return patchesData, patchesLabels


def splitTrainTestSet(X, y, testRatio, randomState=345):
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=testRatio, random_state=randomState, stratify=y)
    return X_train, X_test, y_train, y_test

def create_data_loader(Random):
    if Random == 0:
        X, y = loadData()
        test_ratio = 0.95
        patch_size = 13
        pca_components = 110
        print('Hyperspectral data shape: ', X.shape)
        print('Label shape: ', y.shape)
        print('\n... ... PCA tranformation ... ...')
        X_pca = applyPCA(X, numComponents=pca_components)
        print('Data shape after PCA: ', X_pca.shape)
        print('\n... ... create data cubes ... ...')
        X_pca, y = createImageCubes(X_pca, y, windowSize=patch_size)
        print('Data cube X shape: ', X_pca.shape)
        print('Data cube y shape: ', y.shape)
        print('\n... ... create train & test data ... ...')
        Xtrain, Xtest, ytrain, ytest = splitTrainTestSet(X_pca, y, test_ratio)
        print('Xtrain shape: ', Xtrain.shape)
        print('Xtest  shape: ', Xtest.shape)
        # 改变 Xtrain, Ytrain 的形状，以符合 keras 的要求
        X = X_pca.reshape(-1, patch_size, patch_size, pca_components, 1)
        Xtrain = Xtrain.reshape(-1, patch_size, patch_size, pca_components, 1)
        Xtest = Xtest.reshape(-1, patch_size, patch_size, pca_components, 1)
        print('before transpose: Xtrain shape: ', Xtrain.shape)
        print('before transpose: Xtest  shape: ', Xtest.shape)
        # 为了适应 pytorch 结构，数据要做 transpose
        X = X.transpose(0, 4, 3, 1, 2)
        Xtrain = Xtrain.transpose(0, 4, 3, 1, 2)
        Xtest = Xtest.transpose(0, 4, 3, 1, 2)
        print('after transpose: Xtrain shape: ', Xtrain.shape)
        print('after transpose: Xtest  shape: ', Xtest.shape)
        # 创建train_loader和 test_loader
        X = TestDS(X, y)
        trainset = TrainDS(Xtrain, ytrain)
        testset = TestDS(Xtest, ytest)
        train_loader = torch.utils.data.DataLoader(dataset=trainset,
                                               batch_size=BATCH_SIZE_TRAIN,
                                               shuffle=True,
                                               drop_last=True
                                               )
        test_loader = torch.utils.data.DataLoader(dataset=testset,
                                              batch_size=BATCH_SIZE_TRAIN,
                                              shuffle=False,
                                              num_workers=0,
                                              drop_last=True
                                              )
        all_data_loader = torch.utils.data.DataLoader(dataset=X,
                                                  batch_size=BATCH_SIZE_TRAIN,
                                                  shuffle=False,
                                                  num_workers=0,
                                                  drop_last=True
                                                  )
    if Random == 1:
        X, y = loadData()
        test_ratio = 0.95
        patch_size = 13
        pca_components = 110
        print('Hyperspectral data shape: ', X.shape)
        print('Label shape: ', y.shape)
        print('\n... ... Random Shuffle Data and Label... ...')
        H,W,B = X.shape
        H1,W1 = y.shape
        Data = X.reshape(H*W,B)
        label = y.reshape(H1*W1,-1)
        #合并数据和标签
        finalData = np.hstack((Data,label))
        print("finalData is :\n",finalData.shape)
        #随机打乱合成的新数据finalData的百分之多少的数据集
        num_shuffle = int(finalData.shape[0] * 0.5) #0.2是随机打乱的数
        print("num_shuffle:\n",num_shuffle)
        shuffle_idx = random.sample(range(finalData.shape[0]), num_shuffle)
        # 随机打乱需要打乱的数据
        shuffle_data = np.random.permutation(finalData[shuffle_idx,:])
        # 将随机打乱的数据替换到原向量中
        finalData[shuffle_idx,:] = shuffle_data[:,:]
        #取出打乱后的标签数据，并在打乱的数据中删除标签列
        ly = finalData[:,[-1]]
        Dx = np.delete(finalData,-1,axis=1)
        NewData = Dx.reshape(H,W,B)
        Newlabel = ly.reshape(H1,W1)
        X = NewData
        y = Newlabel
        print('\n... ... Finish Random Shuffle ... ...')
        print('\n... ... PCA tranformation ... ...')
        X_pca = applyPCA(NewData,numComponents=pca_components)#(X, numComponents=pca_components)
        print('Data shape after PCA: ', X_pca.shape)
        print('\n... ... create data cubes ... ...')
        X_pca, y = createImageCubes(X_pca,Newlabel,windowSize=patch_size)#(X_pca, y, windowSize=patch_size)
        print('Data cube X shape: ', X_pca.shape)
        print('Data cube y shape: ', y.shape)
        print('\n... ... create train & test data ... ...')
        Xtrain, Xtest, ytrain, ytest = splitTrainTestSet(X_pca, y, test_ratio)
        print('Xtrain shape: ', Xtrain.shape)
        print('Xtest  shape: ', Xtest.shape)
        # 改变 Xtrain, Ytrain 的形状，以符合 keras 的要求
        X = X_pca.reshape(-1, patch_size, patch_size, pca_components, 1)
        Xtrain = Xtrain.reshape(-1, patch_size, patch_size, pca_components, 1)
        Xtest = Xtest.reshape(-1, patch_size, patch_size, pca_components, 1)
        print('before transpose: Xtrain shape: ', Xtrain.shape)
        print('before transpose: Xtest  shape: ', Xtest.shape)
        # 为了适应 pytorch 结构，数据要做 transpose
        X = X.transpose(0, 4, 3, 1, 2)
        Xtrain = Xtrain.transpose(0, 4, 3, 1, 2)
        Xtest = Xtest.transpose(0, 4, 3, 1, 2)
        print('after transpose: Xtrain shape: ', Xtrain.shape)
        print('after transpose: Xtest  shape: ', Xtest.shape)
        # 创建train_loader和 test_loader
        X = TestDS(X, y)
        trainset = TrainDS(Xtrain, ytrain)
        testset = TestDS(Xtest, ytest)
        train_loader = torch.utils.data.DataLoader(dataset=trainset,
                                               batch_size=BATCH_SIZE_TRAIN,
                                               shuffle=True,
                                               drop_last=True
                                               )
        test_loader = torch.utils.data.DataLoader(dataset=testset,
                                              batch_size=BATCH_SIZE_TRAIN,
                                              shuffle=False,
                                              num_workers=0,
                                              drop_last=True
                                              )
        all_data_loader = torch.utils.data.DataLoader(dataset=X,
                                                  batch_size=BATCH_SIZE_TRAIN,
                                                  shuffle=False,
                                                  num_workers=0,
                                                  drop_last=True
                                                  )

    return train_loader, test_loader, all_data_loader, y


def _weights_init(m):
    classname = m.__class__.__name__
    # print(classname)
    if isinstance(m, nn.Linear) or isinstance(m, nn.Conv3d):
        init.kaiming_normal_(m.weight)


class Residual(nn.Module):
    def __init__(self, fn):
        super().__init__()
        self.fn = fn

    def forward(self, x, **kwargs):
        return self.fn(x, **kwargs) + x


# 等于 PreNorm
class LayerNormalize(nn.Module):
    def __init__(self, dim, fn):
        super().__init__()
        self.norm = nn.LayerNorm(dim)
        self.fn = fn

    def forward(self, x, **kwargs):
        return self.fn(self.norm(x), **kwargs)


# 等于 FeedForward
class MLP_Block(nn.Module):
    def __init__(self, dim, hidden_dim, dropout=0.1):
        super().__init__()
        self.net = nn.Sequential(
            nn.Linear(dim, hidden_dim),
            nn.GELU(),
            nn.Dropout(dropout),
            nn.Linear(hidden_dim, dim),
            nn.Dropout(dropout)
        )

    def forward(self, x):
        return self.net(x)


class Attention(nn.Module):
    def __init__(self, dim, heads=8, dim_head=64, dropout=0.):
        super().__init__()
        inner_dim = dim_head * heads
        self.heads = heads
        self.scale = dim ** -0.5
        self.to_qkv = nn.Linear(dim, inner_dim * 3, bias=False)
        self.to_out = nn.Sequential(nn.Linear(inner_dim, dim), nn.Dropout(dropout)
                                    )

    def forward(self, x, mask=None):
        b, n, _, h = *x.shape, self.heads
        qkv = self.to_qkv(x).chunk(3, dim=-1)
        q, k, v = map(lambda t: rearrange(t, 'b n (h d) -> b h n d', h=h), qkv)
        dots = torch.einsum('bhid,bhjd->bhij', q, k) * self.scale
        mask_value = -torch.finfo(dots.dtype).max

        if mask is not None:
            mask = F.pad(mask.flatten(1), (1, 0), value=True)
            assert mask.shape[-1] == dots.shape[-1], 'mask has incorrect dimensions'
            mask = mask[:, None, :] * mask[:, :, None]
            dots.masked_fill_(~mask, mask_value)
            del mask

        attn = dots.softmax(dim=-1)
        out = torch.einsum('bhij,bhjd->bhid', attn, v)
        out = rearrange(out, 'b h n d -> b n (h d)')
        out = self.to_out(out)
        return out


class Transformer(nn.Module):
    def __init__(self, dim, depth, heads, dim_head, mlp_dim, dropout):
        super().__init__()
        self.layers = nn.ModuleList([])
        for _ in range(depth):
            self.layers.append(nn.ModuleList([
                Residual(LayerNormalize(dim, Attention(dim, heads=heads, dim_head=dim_head, dropout=dropout))),
                Residual(LayerNormalize(dim, MLP_Block(dim, mlp_dim, dropout=dropout)))
            ]))

    def forward(self, x, mask=None):
        for attn, ff in self.layers:
            x = attn(x, mask=mask)
            x = ff(x)
        return x

BATCH_SIZE_TRAIN = 64
NUM_CLASS = 16

class ViT(nn.Module):
    def __init__(self, *, in_channels=1, image_size, patch_size, num_classes, dim, depth, heads,
                 mlp_dim, channels=64, dim_head=64, dropout=0., emb_dropout=0.):
        super().__init__()
        assert image_size % patch_size == 0, 'Image dimensions must be divisible by the patch size.'
        num_patches = (image_size // patch_size) ** 2
        patch_dim = channels * patch_size ** 2
        assert num_patches > NUM_CLASS, f'your number of patches ({num_patches}) is way too small for attention to be effective (at least 16). Try decreasing your patch size'
        self.patch_size = patch_size
        self.pos_embedding = nn.Parameter(torch.randn(1, num_patches + 1, dim))
        self.patch_to_embedding = nn.Linear(110, dim)  # patch_dim, dim)
        self.cls_token = nn.Parameter(torch.randn(1, 1, dim))
        self.dropout = nn.Dropout(emb_dropout)
        self.transformer = Transformer(dim, depth, heads, dim_head, mlp_dim, dropout)
        self.to_cls_token = nn.Identity()
        self.mlp_head = nn.Sequential(
            nn.LayerNorm(dim),
            nn.Linear(dim, num_classes)
        )

        self.conv3d_features = nn.Sequential(
            nn.Conv3d(in_channels, out_channels=32, kernel_size=(3, 3, 3), padding=1),
            nn.BatchNorm3d(32),
            nn.ReLU(),
        )
        self.conv3d_features_1 = nn.Sequential(
            nn.Conv3d(in_channels=33, out_channels=64, kernel_size=(3, 3, 3), padding=1),
            nn.BatchNorm3d(64),
            nn.ReLU(),
        )

        self.conv2d_features = nn.Sequential(
            nn.Conv2d(in_channels=64 * 110, out_channels=64, kernel_size=(3, 3), padding=1),
            nn.BatchNorm2d(64),
            nn.ReLU(),
        )
        self.conv2d_features_1 = nn.Sequential(
            nn.Conv2d(in_channels=7104, out_channels=110, kernel_size=(3, 3), padding=1),
            nn.BatchNorm2d(110),
            nn.ReLU(),
        )

    def forward(self, img, mask=None):
        #print("image size:", img.size())
        res = img
        img = self.conv3d_features(img)
        img = torch.cat((img, res), dim=1)
        img = self.conv3d_features_1(img)
        res1 = rearrange(img, 'b c h w y -> b (c h ) w y')
        # img = self.conv3d_features_2(img)
        # print("after 3D Conv image size:",img.size())
        p = self.patch_size
        img = img.reshape(img.shape[0], img.shape[1] * img.shape[2], img.shape[3], img.shape[4])
        img = self.conv2d_features(img)
        img = torch.cat((img, res1), dim=1)
        # print("image size:",img.size())
        img = self.conv2d_features_1(img)
        # img = self.conv2d_features_3(torch.cat((img1,img2),dim=1))
        # print("after 2D Conv image size:",img.size())
        # print("image size:",img.size())
        x = rearrange(img, 'b c (h p1) (w p2) -> b (h w) (p1 p2 c)', p1=p, p2=p)
        # print("before x:",x.size())
        # x = rearrange(x,'b h w -> b w h')
        # print("rearrange x:",x.size())
        x = self.patch_to_embedding(x)
        # print("after x:",x.size())
        b, n, _ = x.shape
        cls_tokens = repeat(self.cls_token, '() n d -> b n d', b=b)
        x = torch.cat((cls_tokens, x), dim=1)
        x += self.pos_embedding[:, :(n + 1)]
        x = self.dropout(x)
        x = self.transformer(x, mask)
        x = self.to_cls_token(x[:, 0])
        return self.mlp_head(x)

'''
model=ViT(image_size = 13,patch_size = 1,num_classes = 16,dim = 1024,depth = 6,
                heads = 16,mlp_dim = 2048,channels =30,dropout = 0.1,emb_dropout = 0.1)
print("**"*20)
print(model)
'''
""" Training dataset"""
class TrainDS(torch.utils.data.Dataset):
    def __init__(self, Xtrain, ytrain):
        self.len = Xtrain.shape[0]
        self.x_data = torch.FloatTensor(Xtrain)
        self.y_data = torch.LongTensor(ytrain)

    def __getitem__(self, index):
        # 根据索引返回数据和对应的标签
        return self.x_data[index], self.y_data[index]

    def __len__(self):
        # 返回文件数据的数目
        return self.len

""" Testing dataset"""
class TestDS(torch.utils.data.Dataset):
    def __init__(self, Xtest, ytest):
        self.len = Xtest.shape[0]
        self.x_data = torch.FloatTensor(Xtest)
        self.y_data = torch.LongTensor(ytest)

    def __getitem__(self, index):
        # 根据索引返回数据和对应的标签
        return self.x_data[index], self.y_data[index]

    def __len__(self):
        # 返回文件数据的数目
        return self.len


def train(train_loader,train_loader_Random, epochs):
    # 使用GPU训练，可以在菜单 "代码执行工具" -> "更改运行时类型" 里进行设置
    device = torch.device("cuda:0" if torch.cuda.is_available() else "cpu")
    # 网络放到GPU上
    # Transformer(dim, depth, heads, dim_head, mlp_dim, dropout)
    # image_size, patch_size, num_classes, dim, depth, heads,mlp_dim
    # patch_dim = channels * patch_size ** 2
    net = ViT(image_size=21, patch_size=1, num_classes=16, dim=1024, depth=2,
              heads=16, mlp_dim=2048, channels=110, dropout=0.1, emb_dropout=0.1).to(device)
    # 交叉熵损失函数
    criterion = nn.CrossEntropyLoss()
    # 初始化优化器
    optimizer = optim.Adam(net.parameters(), lr=0.001)
    # 开始训练
    total_loss = 0
    for epoch in range(epochs):
        net.train()
        for i, (data, target) in enumerate(train_loader):
            data, target = data.to(device), target.to(device)
            # 正向传播 +　反向传播 + 优化
            # 通过输入得到预测的输出
            outputs = net(data)
            # 计算损失函数
            lossi = criterion(outputs, target)
            for j, (dataj, targetj) in enumerate(train_loader_Random):
                #if j == i:
                dataj, targetj = dataj.to(device), targetj.to(device)
                outputsj = net(dataj)
                lossj = criterion(outputsj, targetj)
                loss = lossi + 0.5*(lossj)
            # 优化器梯度归零
            optimizer.zero_grad()
            # 反向传播
            loss.backward()
            optimizer.step()
            total_loss += loss.item()
            #i = i + 1
        print('[Epoch: %d]   [loss avg: %.4f]   [current loss: %.4f]' % (epoch + 1,
                                                                         total_loss / (epoch + 1),
                                                                         loss.item()))
    print('Finished Training')
    return net, device


def test(device, net, test_loader):
    count = 0
    # 模型测试
    net.eval()
    y_pred_test = 0
    y_test = 0
    for inputs, labels in test_loader:
        inputs = inputs.to(device)
        outputs = net(inputs)
        outputs = np.argmax(outputs.detach().cpu().numpy(), axis=1)
        if count == 0:
            y_pred_test = outputs
            y_test = labels
            count = 1
        else:
            y_pred_test = np.concatenate((y_pred_test, outputs))
            y_test = np.concatenate((y_test, labels))

    return y_pred_test, y_test


def AA_andEachClassAccuracy(confusion_matrix):
    list_diag = np.diag(confusion_matrix)
    list_raw_sum = np.sum(confusion_matrix, axis=1)
    each_acc = np.nan_to_num(truediv(list_diag, list_raw_sum))
    average_acc = np.mean(each_acc)
    return each_acc, average_acc


def acc_reports(y_test, y_pred_test):
    target_names = ['Alfalfa', 'Corn-notill', 'Corn-mintill', 'Corn', 'Grass-pasture', 'Grass-trees', 'Grass-pasture-mowed',
                    'Hay-windrowed', 'Oats', 'Soybean-notill', 'Soybean-mintill','Soybean-clean', 'Wheat', 'Woods',
                    'Buildings-Grass-Trees-Drives','Stone-Steel-Towers']
    classification = classification_report(y_test, y_pred_test, digits=4, target_names=target_names)
    oa = accuracy_score(y_test, y_pred_test)
    confusion = confusion_matrix(y_test, y_pred_test)
    each_acc, aa = AA_andEachClassAccuracy(confusion)
    kappa = cohen_kappa_score(y_test, y_pred_test)

    return classification, oa * 100, confusion, each_acc * 100, aa * 100, kappa * 100


if __name__ == '__main__':
    train_loader, test_loader, all_data_loader, y_all = create_data_loader(Random=0)
    train_loader_Random, test_loader_Random, all_data_loader_Random, y_all_Random = create_data_loader(Random=1)
    tic1 = time.perf_counter()
    net, device = train(train_loader,train_loader_Random, epochs=200)
    # 只保存模型参数
    torch.save(net.state_dict(), '1_net_params.pth')
    toc1 = time.perf_counter()
    tic2 = time.perf_counter()
    y_pred_test, y_test = test(device, net, test_loader_Random)
    # 在原始数据上进行实验
    #y_pred_test, y_test = test(device, net, test_loader_Random)
    toc2 = time.perf_counter()
    # 评价指标
    classification, oa, confusion, each_acc, aa, kappa = acc_reports(y_test, y_pred_test)
    classification = str(classification)
    Training_Time = toc1 - tic1
    Test_time = toc2 - tic2
    time = time.strftime("%Y-%m-%d-%H:%M:%S",time.localtime())
    file_name = "./"+str(time)+"_0.2_HSI_classification_0.05_IP_epochs_200_report.txt"
    with open(file_name, 'w') as x_file:
        x_file.write('{} Training_Time (s)'.format(Training_Time))
        x_file.write('\n')
        x_file.write('{} Test_time (s)'.format(Test_time))
        x_file.write('\n')
        x_file.write('{} Kappa accuracy (%)'.format(kappa))
        x_file.write('\n')
        x_file.write('{} Overall accuracy (%)'.format(oa))
        x_file.write('\n')
        x_file.write('{} Average accuracy (%)'.format(aa))
        x_file.write('\n')
        x_file.write('{} Each accuracy (%)'.format(each_acc))
        x_file.write('\n')
        x_file.write('{}'.format(classification))
        x_file.write('\n')
        x_file.write('{}'.format(confusion))
